/*******************************************************************************
********************************************************************************
********************************************************************************
******
******  Version:   1.0                    
******                                    
******  File:      madx.l 
******                                                                
******  Copyright (c) Universities Research Association, Inc./ Fermilab    
******                All Rights Reserved                             
******                                                                
******  Usage, modification, and redistribution are subject to terms          
******  of the License supplied with this software.
******  
******  Software and documentation created under 
******  U.S. Department of Energy Contract No. DE-AC02-76CH03000. 
******  The U.S. Government retains a world-wide non-exclusive, 
******  royalty-free license to publish or reproduce documentation 
******  and software for U.S. Government purposes. This software 
******  is protected under the U.S. and Foreign Copyright Laws. 
******
******  Author:   Jean-Francois Ostiguy, ostiguy@fnal.gov                                      
******            Fermilab                                           
******
******
**********************************************************************************
**********************************************************************************
*********************************************************************************/
/*----------------------------------------------*/
/* A yacc (bison) parser for MADX input files  */
/*----------------------------------------------*/

%debug
%error-verbose

%skeleton "lalr1.cc"
%define   "parser_class_name" "MadxParser"
%output="MadxParser_ypp.cc"
%lex-param   {void* yyscanner} 
%parse-param {void* yyscanner}
%name-prefix="madx_yy"
%{

#include <iostream>
#include "MadxParserDriver.h"
#include <cmath>

%}

%defines
%parse-param {MadxParserDriver& driver}
%lex-param   {MadxParserDriver& driver}
%locations

%initial-action 
{
   // Initialize the initial location.
   @$.begin.filename = @$.end.filename = &driver.m_file;
}

%union
{
  int               ival;
  double            dval;
  std::string*      sval;    /* string could/should be allocated from a pool to avoid leaks */ 
  Expression*       pexp; 
}


%token    MADX_VARIABLE

%token    MADX_REAL
%token    MADX_INTEGER
%token    MADX_CONST
%token    MADX_SHARED
%token    MADX_SEQUENCE
%token    MADX_SEQUENCE_ELEMENT
%token    MADX_ENDSEQUENCE
%token    MADX_IDENTIFIER

%token    MADX_VALUE
%token    MADX_INT_VALUE
%token    MADX_STRING_VALUE

%token    MADX_ASSIGN
%token    MADX_AT
%token    MADX_FROM
%token    MADX_REFER
%token    MADX_CENTRE

%token    MADX_SQRT
%token    MADX_SIN
%token    MADX_COS
%token    MADX_TAN
%token    MADX_ASIN
%token    MADX_ACOS
%token    MADX_ATAN
%token    MADX_EXP
%token    MADX_LOG
%token    MADX_LOG10
%token    MADX_GAUSS
%token    MADX_TGAUSS
%token    MADX_RANF


%left '+' '-'
%left '*' '/' 
%left '^' 
%left NEG    /* negation, unary minus */

%start program;

%% 

program:
       |
       program statement ';'
       ;

statement: 
       constant_declaration
       |
       variable_assignement
       |
       const_assignement
       |
       element_declaration
       |
       sequence_declaration
       ;


constant_declaration:
       MADX_REAL     MADX_CONST  MADX_IDENTIFIER '=' expr                                   { driver.m_constants[*$<sval>3] = $<dval>5; delete $<sval>3; }
       |
       MADX_INTEGER   MADX_CONST MADX_IDENTIFIER '=' expr                                   { driver.m_constants[*$<sval>3] = $<ival>5; delete $<sval>3; }
       ; 

const_assignement:
       MADX_IDENTIFIER '=' expr                                                              { driver.m_constants[*$<sval>1] = $<dval>3;   delete $<sval>1;
       ;                                                                                       // could be a variable too ! 
                                                                                             }

variable_assignement:
       MADX_IDENTIFIER MADX_ASSIGN vexpr                                                     { 
                                                                                               driver.m_variables[*$<sval>1] = Expression( *$<pexp>3 );
                                                                                               delete $<pexp>3;
                                                                                               delete $<sval>1; }
       ;

sequence_declaration:
       MADX_SHARED MADX_IDENTIFIER ':'  MADX_SEQUENCE  ',' sequence_declaration_attributes ';' sequence_element_declarations  MADX_ENDSEQUENCE { 
                                                                                              driver.defineSequence( *$<sval>2, "SEQUENCE", true);  
                                                                                              delete $<sval>2; }
       |
       MADX_IDENTIFIER ':'  MADX_SEQUENCE  ',' sequence_declaration_attributes ';' sequence_element_declarations  MADX_ENDSEQUENCE { 
                                                                                              driver.defineSequence( *$<sval>1, "SEQUENCE", false); 
                                                                                              delete $<sval>1; }
       ;



sequence_declaration_attributes:
       sequence_declaration_attributes ',' sequence_declaration_attribute
       |
       sequence_declaration_attribute
       ;

sequence_declaration_attribute:
       MADX_REFER        '='  MADX_CENTRE                                                  
       |
       MADX_IDENTIFIER   '='         expr
       |
       MADX_IDENTIFIER   MADX_ASSIGN vexpr
       ;


sequence_element_declarations:                                                              
	sequence_element_declarations sequence_element_declaration
        |
        sequence_element_declaration 
        ;

sequence_element_declaration:
	 MADX_IDENTIFIER ',' sequence_element_attributes ';'                                { driver.addSequenceElement("", *$<sval>1 );
                                                                                              delete $<sval>1;
                                                                                            } 
        |
	 MADX_IDENTIFIER ':' MADX_IDENTIFIER ',' sequence_element_attributes ';'            { driver.addSequenceElement(*$<sval>1 , *$<sval>3);
                                                                                              delete $<sval>1;
                                                                                              delete $<sval>3;
                                                                                            }
       ;


sequence_element_attributes:
       sequence_element_attributes ',' sequence_element_attribute
       |
       sequence_element_attribute
       ;

sequence_element_attribute:
       MADX_AT '=' expr                                                                      { driver.m_attributes_stack.push(value_t("AT", $<dval>3));   } 
       |            
       MADX_FROM '=' MADX_IDENTIFIER                                                         { driver.m_attributes_stack.push(value_t("FROM", *$<sval>3));
                                                                                               delete $<sval>3; } 
       ;


element_declaration:
       MADX_SHARED MADX_IDENTIFIER                                                           { driver.defineElement("", *$<sval>2, true);
                                                                                               delete $<sval>2;  }                                                
       |                                    
       MADX_SHARED MADX_IDENTIFIER ',' attributes                                            { driver.defineElement("", *$<sval>2, true);
                                                                                               delete $<sval>2;  }
       |
       MADX_SHARED MADX_IDENTIFIER ':'  MADX_IDENTIFIER                                      { driver.defineElement(*$<sval>2, *$<sval>4, true);
                                                                                               delete $<sval>2; delete  $<sval>4; }
       |
       MADX_SHARED MADX_IDENTIFIER ':'  MADX_IDENTIFIER ',' attributes                       { driver.defineElement(*$<sval>2, *$<sval>4, true);
                                                                                               delete $<sval>2; delete  $<sval>4; 
                                                                                             }
       |
       MADX_IDENTIFIER                                                                       { driver.defineElement("", *$<sval>1, false);
                                                                                               delete $<sval>1;  /* is this valid ? */} 
       |                                    
       MADX_IDENTIFIER ',' attributes                                                        { driver.defineElement("", *$<sval>1, false);
                                                                                               delete $<sval>1;  }
       |
       MADX_IDENTIFIER ':'  MADX_IDENTIFIER                                                  { driver.defineElement(*$<sval>1, *$<sval>3, false);
                                                                                               delete $<sval>1;  delete $<sval>3; /* is this valid ? */ } 
       |
       MADX_IDENTIFIER ':'  MADX_IDENTIFIER ',' attributes                                   {  driver.defineElement(*$<sval>1, *$<sval>3, false);
                                                                                                delete $<sval>1;  delete $<sval>3;  
                                                                                             } 
       ;


attributes:
       attributes ',' attribute                                                               
       |
       attribute                                                                              
       ;

attribute:
       MADX_IDENTIFIER                                                                       { driver.m_attributes_stack.push(value_t(*$<sval>1, 0));  
                                                                                               delete $<sval>1; }
       |
       MADX_IDENTIFIER '=' expr                                                              { driver.m_attributes_stack.push(value_t(*$<sval>1, $<dval>3 ));
                                                                                               delete $<sval>1; }
       |
       MADX_IDENTIFIER '=' '{' expr_list '}'                                                 { driver.m_attributes_stack.push(value_t( *$<sval>1, 0));
                                                                                               delete $<sval>1; }
       |
       MADX_IDENTIFIER  MADX_ASSIGN  vexpr                                                   { 
                                                                                               driver.m_attributes_stack.push(value_t( *$<sval>1, *$<pexp>3 )); 
                                                                                               delete $<sval>1;
                                                                                               delete $<pexp>3;
                                                                                             }
       |
       MADX_IDENTIFIER  MADX_ASSIGN '{' vexpr_list '}'                                       { driver.m_attributes_stack.push(value_t( *$<sval>1, 0)); 
                                                                                               delete $<sval>1; }
       ; 



 /* ------------------------------------------------------------------------------------------------------------------------*/
 /* expr are constant expressions. constant expressions are evaluated immediately and cannot change                         */
 /* ------------------------------------------------------------------------------------------------------------------------*/


expr_list:
       expr_list ',' expr
       |
       expr
       ;

expr:  vexpr                            {  $<dval>$ = ($<pexp>1)->evaluate(); } 



  
 /* -----------------------------------------------------------------------------------------------------------*/
 /* vexpr are variable expressions. Variable expressions are saved in a tree structure for deferred evaluation */
 /* -----------------------------------------------------------------------------------------------------------*/


vexpr: MADX_INT_VALUE                   { Expression* p = $<pexp>$ = new Expression();
                                          p->insert( ExprData( $<ival>1)  );   
                                        } 
       |
       MADX_VALUE                       {  Expression* p = $<pexp>$ = new Expression();  
                                           p->insert( ExprData( $<dval>1) );
                                        }
       |
       MADX_IDENTIFIER                  {  
                                           Expression* p = $<pexp>$ = new Expression();

                                           std::map<std::string, boost::any>::const_iterator it_consts;
                                           std::map<std::string, Expression>::const_iterator it_vars;

                                           if ( (it_consts=driver.m_constants.find( *($<sval>1) )) != driver.m_constants.end() ) {   
                                                 p->insert( ExprData( boost::any_cast<double>( it_consts->second ) ) );

                                           }
                                           else if ( (it_vars=driver.m_variables.find( *($<sval>1) )) != driver.m_variables.end() ) {
                                                 p->insert(  *it_vars->second.begin() );
                                           }
                                           else{ 
                                                 std::cout << "Warning: " << *$<sval>1 << " is undefined." <<std::endl;
                                                 std::cout << "Defining variable with value 0.0." << std::endl;
                                                 p->insert( ExprData( 0.0 ) ); 
                                                 driver.m_variables[*($<sval>1)] = *p;
                                           }
                                           delete ( $<sval>1 );
                                        } 
                                          
       |
       '-' vexpr %prec NEG              { 
                                          Expression* p  = $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(NEG)));
                                          q->insert( *($<pexp>2)->begin() );
                                          delete ($<pexp>2);
                                        }
       |
        vexpr '+' vexpr                 { 
                                          Expression* p  = $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token('+')));
                                          q->insert( *($<pexp>1)->begin() );
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>1);
                                          delete ($<pexp>3);
                                        } 
       |                                                                               
        vexpr '-' vexpr                 { 
                                          Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token('-')));
                                          q->insert( *($<pexp>1)->begin() );
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>1);
                                          delete ($<pexp>3);

                                        }
       | 
        vexpr '*' vexpr                 { 
                                          Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token('*')));
                                          q->insert( *($<pexp>1)->begin() );
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>1);
                                          delete ($<pexp>3);
                                        }
       |   
        vexpr '/' vexpr                 { 
                                          Expression* p  =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token('/')));
                                          q->insert( *($<pexp>1)->begin() );
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>1);
                                          delete ($<pexp>3);
                                        }

       |
        vexpr '^' vexpr                 {
                                          $<pexp>$ = new Expression();                      
                                          Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token('^')));
                                          q->insert( *($<pexp>1)->begin() );
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>1);
                                          delete ($<pexp>3);
                                        } 
       |
        '(' vexpr ')'                   { $<pexp>$ =  $<pexp>2; }
       | 
       vfunction                        { $<pexp>$ =  $<pexp>1; } 
       ;

vfunction:

        MADX_SQRT '(' vexpr ')'         {                                           
                                          Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_SQRT)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |
        MADX_SIN '(' vexpr ')'          { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_SIN)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |
        MADX_COS '(' vexpr ')'          { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_COS)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |
        MADX_TAN '(' vexpr ')'          { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_TAN)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |        
       MADX_ASIN '(' vexpr ')'          { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_ASIN)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |        
       MADX_ACOS '(' vexpr ')'          { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_ACOS)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |        
       MADX_ATAN '(' vexpr ')'          { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_ATAN)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |
       MADX_EXP '(' vexpr ')'          { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_EXP)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |
       MADX_LOG '(' vexpr ')'           { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_LOG)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |
       MADX_LOG10 '(' vexpr ')'         { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_LOG10)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |
       MADX_GAUSS '(' vexpr ')'          { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_GAUSS)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |
       MADX_TGAUSS '(' vexpr ')'          { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_TGAUSS)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       |
       MADX_RANF '(' vexpr ')'          { Expression* p     =  $<pexp>$  = new Expression();       
                                          expr_iterator_t q = p->insert(ExprData(Token(MADX_RANF)));
                                          q->insert( *($<pexp>3)->begin() );
                                          delete ($<pexp>3);
                                        }
       ;
      


vexpr_list:
       vexpr_list ',' vexpr
       |
       vexpr
       ;



%%
void
yy::MadxParser::error(const yy::MadxParser::location_type& l, const std::string& m )
{

    driver.error(l,m);
 
}


