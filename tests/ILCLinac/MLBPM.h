#ifndef _h_MLBPM
#define _h_MLBPM 1

#include <basic_toolkit/Distribution.h>
#include <basic_toolkit/MathConstants.h>
#include <basic_toolkit/PhysicsConstants.h>
#include <vector>
#include <beamline/monitor.h>

//! \brief Beam Position Monitor Class
/*!
   Optimize for simple Steering studies and inheriting from a CHEF Monitor.
   This BPM is either horizontal or vertical. 
   Vertical orientation has been test, Horizontal has never been used.
   
   So far, resolution model is Gaussian. 
   
   Can work on a signle particle, or a bunch. Either integrate over many 
   bunches, or work on a signal bunch. 
   
   Default Units here are microns, not meters. 
   
  Paul Lebrun, 2006-2007, finalized Feb 2008. 
*/
class MLBPM: public monitor { // Smart beamline Pointer of type Monitor

public:
    /*! Recommended Constructor. 
      \param id  Sequential number along the beam line. Easiest and 
          recommended numerology. 
       \param sp  The longitudinal coordinate, aling the beam line. 
       \param isHorizontal By default, we deal with vertical BPMs 
    */
    explicit MLBPM(int id, double sp, bool isHorizontal=false); 
      // the sequential index in the model and a Z location
    /*! \brief CHEF Monitor has a null constructor.
     * Confusing.. 
    */ 
    MLBPM(); // Index will be zero, to satisfy dummy constructor..
    ~MLBPM();
    
    /*! \brief Set an Offset. 
     \param v Offset, units in microns. 
    */     
    inline void SetOffset(double v) {offset = v;}  
    /*! \brief Set a fitted Offset, for futur use.. 
     \param v Offset units in microns. 
    */     
    inline void SetFittedOffset(double v) {fittedOffset = v;}  

    /*! \brief Get a Measurement, after beam gone through.
         Units are in microns. 
    */     
    inline double GetMeasurement() const {return value;}
    /*! \brief Set the resolution.  Measured value (or response )  is 
          Offset + position*scale + random Gaussian(0., sigma)
        \param sigma  The BPM resolutions. 
	\param scale  scale factor constant error. 
	  
    */     
    void SetResolution(double sigma, double scale = 1.);
    //!  \brief Set the scale factor.  See def. above. 
    /*!
     \param v  scale factor constant error. 
   */     
    inline void SetScale(double v) {scale = v;}
    inline double GetResolution() const {return resolution;}
    inline double GetScale() const {return scale;}
    inline int GetId() const {return id;} 
    inline double GetError() const {return error;}
    inline double GetOffset() const {return offset;}
    inline double GetFittedOffset() const {return fittedOffset;}
    inline double GetZPosition()const {return zPos;} 
    inline double GetCTime() const {return ct;} 
    inline bool isHorizontal() const {return horizontal;} 
    
    //! \brief Integration mode. 
    /*!
         By default, previous measurements are overwritten, for particle,
	  pilot bunches or nominal intensity bunches. 
	  By setting this to true, the new position is average with the 
	  previous one, to gain accuracy. 
	\param integrate Bool, if set true, keep measuring without reseting. 
	  
    */     

    inline void IntegrateOn(bool t) {integrate = t;} 
    /*! \brief Get the average reading over bunches. 
           (Value here  is measured position. 
	    to be improved, proper treatment of errors..) 
	\param n the number of bunches 
    */     
    inline void Average(int n) {value /= n;} 
    inline void Reset() {value = 0.;} 
    
    /*! \brief Local Propagate method, Called by CHEF  
           (Value here  is measured position. 
	\param p    The CHEF particle.  
    */     
    
    void localPropagate (Particle& p); 
    /*! \brief Local Propagate method, Called by CHEF  
           (Value here  is measured position. 
	\param pb    The CHEF Bunch particle.  
    */     
    
    void localPropagate (ParticleBunch& pb); 
    
private:
   
   const int id; // The index   
   bool integrate; 
      // add signal bunches after bunches, no over-write of the info. 
   const double zPos; // the set position along my beamline.  

   double ct; // the recorded longitudinal position value  
   double value; // the measured value, includes jitter + offset + resolution  
   double error; // not necessary equal to resolution, to allow for 
                 // adapted optimization ( whatever that means..) 
   double offset; // systematic offset, as generated by mis-alignment, 
                  // ground motion, whatever 
   double fittedOffset; // Reconstructed systematic offset, as deduced from the fit.   
   bool horizontal;
   double resolution; // Could be static, but not all BPMs are equal... 
   double scale;
   
   static Gaussian myGauss;
};


#endif
